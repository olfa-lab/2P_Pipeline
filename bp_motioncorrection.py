"""Create and submit SLURM job script to motion correct set of TIFFs.
"""
import argparse
import logging
import os
import subprocess
import sys

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler(stream=sys.stdout))
logger.setLevel(logging.INFO)

MATLAB_SCRIPT_NAME = "normcorremotioncorrection_single"
TEMPLATE_SCRIPT = """#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=10
#SBATCH --time=5:00:00
#SBATCH --mem=60GB
#SBATCH --job-name=motionCorrectionTest
#SBATCH --mail-type=END
#SBATCH --mail-user={email}
#SBATCH --output=slurm_%j.out
#SBATCH --array=0-{numTIFFsMinusOne}
# Auto-generated by bp_motioncorrection.py

module purge
module load matlab/R2018a

cd {workingDir}

{extendedGlob}
tifs=(`pwd`/{pattern})

tif=${{tifs[$SLURM_ARRAY_TASK_ID]}}

{{
    echo $tif
    matlab -nodisplay -r "{matlab_script}('$tif','{refName}'); exit"
}} > $tif.log 2>&1

exit
"""


def run_shell_command(scommand, capture_output=False):
    """Execute a shell command.

    Arguments:
        scommand {str} -- Command to be executed verbatim.

    Keyword Arguments:
        capture_output {bool} -- Allow the output from the command to be accessed via the
            .stdout attribute on the returned CompletedProcess. (default: {False})

    Raises:
        RuntimeError: Raised if the command returns a non-zero return code.

    Returns:
        subprocess.CompletedProcess -- Result of subprocess.run.
    """
    logger.debug("About to run:\n{}".format(scommand))
    if capture_output:
        process_results = subprocess.run(scommand, shell=True, stdout=subprocess.PIPE)
    else:
        process_results = subprocess.run(scommand, shell=True)
    if process_results.returncode:
        raise RuntimeError("Received non-zero return code: {}".format(process_results))
    return process_results


def fill_in_template(template, params):
    """Fill in template placeholders according to params.

    Arguments:
        template {str} -- Template string.
        params {dict} -- Dict requires a key matching each template string placeholder
            variable name. Corresponding values will be inserted.

    Returns:
        str -- Populated template string.
    """
    return template.format(**params)


def make_mc_submit_script(
    params,
    fname="submit_motioncorrection.sh",
    template=TEMPLATE_SCRIPT,
    matlab_script=MATLAB_SCRIPT_NAME,
):
    """Create TIFF motion correction submit script for SLURM

    Arguments:
        params {dict} -- Dict of parameters for the script template. 'extendedglob' and
            'numTIFFsMinusOne' added automatically.

    Keyword Arguments:
        fname {str} -- Filename for created script. (default:
            {"submit_motioncorrection.sh"})
        template {str} -- Template script. (default: {TEMPLATE_SCRIPT})

    Raises:
        RuntimeError: Raised if extended globbing feature ! is included in pattern.

    Returns:
        str -- Filepath of created script.
    """
    params["matlab_script"] = matlab_script
    # check if we need to turn extended glob option on
    # NOTE: This is currently pointless, as it does not seem possible to live test the
    # pattern in the shell while getting the number of TIFs if the pattern uses extended
    # globbing.
    if "!" in args.pattern:
        params["extendedGlob"] = "shopt -s extglob\n"
        # TODO: Remove this error once extended globbing possible in TIF count test.
        raise RuntimeError(f"Cannot handle ! in pattern: {args.pattern}")
    else:
        params["extendedGlob"] = ""
    # get number of TIFs Minus One -- need to specify last index in a zero-index array
    scommand = f"ls {os.path.join(params['workingDir'], '')}{params['pattern']} | wc -l"
    ls_result = run_shell_command(scommand, capture_output=True)
    params["numTIFFsMinusOne"] = int(ls_result.stdout) - 1

    script = fill_in_template(template, params)
    fname = os.path.abspath(os.path.expanduser(fname))
    with open(fname, "w") as scriptFile:
        scriptFile.write(script)
    logger.info(f"Submit script written to {fname}")
    return fname


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--workingDir", default=".", help="Working directory containing tifs to correct"
    )
    parser.add_argument(
        "--pattern",
        # Default will include all TIFF
        default="*.tif",
        help="File name pattern to select tifs, i.e. Run0034_00*.tif.",
    )
    parser.add_argument(
        "--refName",
        default="Ref.tif",
        help="File name of reference tif to be used by motion correction script.",
    )
    try:
        parser.add_argument(
            "--email",
            default=f'{os.getenv("USER")}@nyu.edu',
            help="Notification email address.",
        )
    except OSError:
        parser.add_argument(
            "--email",
            required=True,
            help="Notification email address. Entry required on your system.",
        )
    parser.add_argument(
        "--run", action="store_true", help="Run the submit script after creating."
    )
    args = parser.parse_args()

    scriptFilename = make_mc_submit_script(vars(args))
    if args.run:
        result = run_shell_command(f"sbatch {scriptFilename}")
