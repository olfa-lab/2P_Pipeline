import logging
import os
import subprocess
import sys
from typing import Any, Dict, Mapping, Sequence, Union

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler(stream=sys.stdout))
logger.setLevel(logging.INFO)


class SlurmScript:
    """Slurm script creation and execution.

    Parameters:
        scriptFilename (str): Where to save the script.
        payload (str): Commands to be executed by the cluster. Can contain replacement
            fields that reference other arguments passed to this constructor, including
            additional keyword arguments.
        job_name (str): Name the cluster will list for the job(s) created.
        email (str, optional): Your notification email. If not provided, will attempt to
            autodetect.
        nodes (int, optional): Cluster parameter. Defaults to 1.
        ntasks_per_node (int, optional): Cluster parameter. Defaults to 1.
        cpus_per_task (int, optional): Cluster parameter. Defaults to 10.
        time (str, optional): Cluster parameter. Defaults to "5:00:00".
        mem (str, optional): Cluster parameter. Defaults to "60GB".
        mail_type (str, optional): Cluster parameter. Defaults to "END".
        output (str, optional): File to pipe stdout and stderr. Defaults to "slurm_%j.out"
            (%j is replaced with the job ID#).
        array (Union[str, Sequence[int]], optional): Array specifications. If a str, it is
            used as the value for the --array parameter in the script. If a sequence of
            ints, they are used as the array indices to process. Defaults to None, in
            which case no array execution is done (single job).

    Attributes:
        TEMPLATE_SCRIPT (str): Script template. Default contains standard Slurm script
            directives.
        params (Dict[str, Any]): Contents used to populate replacement fields in payload
            and TEMPLATE_SCRIPT to form script.
        script (str): Script text to be submitted to the cluster.
        scriptFilename (str): Filename of script on the filesystem.
    """

    TEMPLATE_SCRIPT = """#!/bin/bash
#SBATCH --nodes={nodes}
#SBATCH --ntasks-per-node={ntasks_per_node}
#SBATCH --cpus-per-task={cpus_per_task}
#SBATCH --time={time}
#SBATCH --mem={mem}
#SBATCH --job-name={job_name}
#SBATCH --mail-type={mail_type}
#SBATCH --mail-user={email}
#SBATCH --output={output}
{array_text}
# Auto-generated by SlurmScript.py, written to {scriptFilename}

{payload}

exit
"""
    params: Dict[str, Any]
    script: str

    def __init__(
        self,
        scriptFilename: str,
        payload: str,
        job_name: str,
        email: str = None,
        nodes: int = 1,
        ntasks_per_node: int = 1,
        cpus_per_task: int = 10,
        time: str = "5:00:00",
        mem: str = "60GB",
        mail_type: str = "END",
        output: str = "slurm_%j.out",
        array: Union[str, Sequence[int]] = None,
        **kwargs,
    ):
        self.scriptFilename = scriptFilename
        self.params = {}
        if email is None:
            try:
                email = f'{os.getenv("USER")}@nyu.edu'
            except OSError as E:
                logger.critical("Email must be provided. Automatic detection failed.")
                raise E
        params = locals().copy()
        del params["self"]
        del params["kwargs"]
        params.update(kwargs)
        if array is None:
            params["array_text"] = ""
        elif isinstance(array, str):
            params["array_text"] = f"#SBATCH --array={array}"
        else:  # isinstance(array, Sequence[int])
            params[
                "array_text"
            ] = f"#SBATCH --array={str(list(array))[1:-1].replace(' ', '')}"
        self.update(params)

    def __str__(self):
        return self.script

    def update(self, newParams: Dict[str, Any]):
        """Updates the script with new parameters. Also updates params attribute.

        Args:
            newParams (Dict[str, Any]): New parameters. Will overwrite any existing
                parameters with the same key.
        """
        self.params.update(newParams)
        args = self.params.copy()
        args["payload"] = self.fill_in_template(args["payload"], args)
        self.script = self.fill_in_template(self.TEMPLATE_SCRIPT, args)

    def save(self) -> str:
        """Save script to file.

        Returns:
            str: Filesystem location of script.
        """
        fname = os.path.abspath(os.path.expanduser(self.scriptFilename))
        with open(fname, "w") as scriptFile:
            scriptFile.write(self.script)
        logger.info(f"Submit script written to {fname}")
        return fname

    def run(self) -> subprocess.CompletedProcess:
        """Run script. Saves before running.

        Returns:
            subprocess.CompletedProcess: Result of shell command.
        """
        fname = self.save()
        result = self.run_shell_command(f"sbatch {fname}")
        return result

    @staticmethod
    def run_shell_command(
        scommand: str, capture_output: bool = False
    ) -> subprocess.CompletedProcess:
        """Execute a shell command.

        Arguments:
            scommand {str} -- Command to be executed verbatim.

        Keyword Arguments:
            capture_output {bool} -- Allow the output from the command to be accessed via
                the .stdout attribute on the returned CompletedProcess. (default: {False})

        Raises:
            RuntimeError: Raised if the command returns a non-zero return code.

        Returns:
            subprocess.CompletedProcess -- Result of subprocess.run.
        """
        logger.debug("About to run:\n{}".format(scommand))
        if capture_output:
            process_results = subprocess.run(
                scommand, shell=True, stdout=subprocess.PIPE
            )
        else:
            process_results = subprocess.run(scommand, shell=True)
        if process_results.returncode:
            raise RuntimeError(
                "Received non-zero return code: {}".format(process_results)
            )
        return process_results

    @staticmethod
    def fill_in_template(template: str, params: Mapping[str, Any]):
        """Fill in template placeholders according to params.

        Arguments:
            template {str} -- Template string.
            params {dict} -- Dict requires a key matching each template string placeholder
                variable name. Corresponding values will be inserted.

        Returns:
            str -- Populated template string.
        """
        return template.format(**params)


if __name__ == "__main__":
    # Example usage
    testPayload = """touch {myFname}
echo $SLURM_ARRAY_TASK_ID >> {myLog}
"""
    testScript = SlurmScript(
        "test.sh",
        testPayload,
        "testJob",
        "email@nyu.edu",
        array="0-4",
        myFname="myTestFile$SLURM_ARRAY_TASK_ID.TEST",
        myLog="myLog.log",
    )
    print(testScript)
    result = testScript.save()
